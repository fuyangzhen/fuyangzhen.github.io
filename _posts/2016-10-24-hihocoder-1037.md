---
layout: post
title: "hihocoder 1037 — 数字三角形"
tags: [dna, hihocoder, oj]
comments: true
date: 2016-10-24 00:00:00
---

## 1 简介
### 问题描述
一个被称为“数字三角形”的n(n不超过200)层迷宫，这个迷宫的第i层有i个房间，分别编号为1..i。除去最后一层的房间，每一个房间都会有一些通往下一层的房间的楼梯，用符号来表示的话，就是从第i层的编号为j的房间出发会有两条路，一条通向第i+1层的编号为j的房间，另一条会通向第i+1层的编号为j+1的房间，而最后一层的所有房间都只有一条离开迷宫的道路。这样的道路都是单向的，也就是说当沿着这些道路前往下一层的房间或者离开迷宫之后，小Ho没有办法再次回到这个房间。迷宫里同时只会有一个参与者，而在每个参与者进入这个迷宫的时候，每个房间里都会生成一定数量的奖券，这些奖券可以在通过迷宫之后兑换各种奖品。小Ho的起点在第1层的编号为1的房间，现在小Ho悄悄向其他参与者弄清楚了每个房间里的奖券数量，希望小Hi帮他计算出他最多能获得多少奖券。  

<!--more-->  

### 输入
每个测试点（输入文件）有且仅有一组测试数据。

每组测试数据的第一行为一个正整数n,表示这个迷宫的层数。

接下来的n行描述这个迷宫中每个房间的奖券数，其中第i行的第j个数代表着迷宫第i层的编号为j的房间中的奖券数量。

测试数据保证，有100%的数据满足n不超过100

对于100%的数据，迷宫的层数n不超过100

对于100%的数据，每个房间中的奖券数不超过1000

对于50%的数据，迷宫的层数不超过15（小Ho表示2^15才3万多呢，也就是说……）

对于10%的数据，迷宫的层数不超过1（小Hi很好奇你的边界情况处理的如何？~）

对于10%的数据，迷宫的构造满足：对于90%以上的结点，左边道路通向的房间中的奖券数比右边道路通向的房间中的奖券数要多。

对于10%的数据，迷宫的构造满足：对于90%以上的结点，左边道路通向的房间中的奖券数比右边道路通向的房间中的奖券数要少。

### 输出
对于每组测试数据，输出一个整数Ans，表示小Ho可以获得的最多奖券数。

### 样例输入

```py
5
2
6 4
1 2 8
4 0 9 6
6 5 5 3 6
```
### 样例输出

```py
28
```  
## 2 实现

```py
while True:
    try:
        n = int(raw_input().strip())
        rewards = [[]] * n
        for i in xrange(n):
            rewards[i] = [int(x) for x in raw_input().strip().split()]
        best = [[]]
        best[0] = rewards[0]

        for i in xrange(1, n):
            best.append([])
            for j in xrange(0, i + 1):
                if j == 0:
                    best[i].append(best[i - 1][j] + rewards[i][j])
                elif j == i:
                    best[i].append(best[i - 1][j - 1] + rewards[i][j])
                else:
                    best[i].append(max(best[i - 1][j], best[i - 1][j - 1]) + rewards[i][j])

        print max(best[n - 1])
    except EOFError:
        break
```  
## 3 总结

```py
a = [[]]*5 # 广播list
b = [[], [], [], [], []] # 普通list

# 对于广播list，对某一元素操作 append, insert, pop 方法会被广播到所有元素当中去：
a[2].append(7) # [[7], [7], [7], [7], [7]]
b[2].append(7) # [[], [], [7], [], []]
```